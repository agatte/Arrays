/*------------------------------------------------------------The dynamic Halloween Bag container class.Anthony Gatte-------------------------------------------------------------*/#include "dynamicArrays.h"#include <cassert>// ************************** Public Functions *********************// This constructor initializes the array container to be empty (size=0)// The bag is constructed to contain 42 slots if no user value is specified.DynamicArrays::DynamicArrays (int initArraySize) {    // Insure a valid initial bag size    assert (initArraySize > 0);    bagSize = initArraySize;    bag = new int[bagSize];    size = 0;}// The destructor deletes the dyanmically allocated arrayDynamicArrays::~DynamicArrays () {    delete [] bag;}// Return to the caller the total number of objects stored// in the list.// Postconditions: returned value is >= 0.int DynamicArrays::Size () const {    return (size);}// Return to the caller the object stored at the specified// location// Precondition: 0 <= index < sizeint DynamicArrays::Get (int index) const {    // Insure valid index    assert (index >= 0 && index < size);    return (bag[index]);}// Add the given element to the list// Preconditions: none.// Postconditions: array[size]=element, size++void DynamicArrays::Add (int element) {	if (size == bagSize) {		DoubleList();	}	bag[size] = element;	size++;}// Add the given element to the list.// Preconditions: 0 <= index <= size// Postconditions: array[index]=element, size++//	This shifts "right" all elements whose index is greater than indexvoid DynamicArrays::Add (int index, int element) {	assert (index >= 0 && index <= size);	if (size == bagSize) {		DoubleList();	}	//Shift items right	for (int i=size; i > index; i--){		bag[i] = bag[i-1];	}	bag[index] = element;	size++;}// Remove the indicated element from the list// Preconditions: 0 <= index < size// Postconditions: size--; all elements to the right of index, shifted left oneint DynamicArrays::Remove (int index) {    // Insure valid index    assert (index >= 0 && index < size);	int retValue = bag[index];	// shift elements left	for (int i=index; i < (size-1); i++){		bag[i] = bag[i+1];	}	size--;	return (retValue);}// Clear all the elements from the list// Preconditions: none// Postconditions: size = 0void DynamicArrays::Clear () {	size = 0;}// ************************** Private Functions *********************void DynamicArrays::DoubleList() {	bagSize = bagSize *2;	// allocate a new array	int *temp = new int[bagSize];	// Copy over items from old array	for (int i=0; i < size; i++) {		temp[i] = bag[i];	}	// delete old list	delete [] bag;	bag = temp;}// Removes first element in the array and returns it// Preconditions: 0 is less than the size of the array// Postconditions: The size of the array will be array - 1 and all the elements to the right of the first element will be shifted overint DynamicArrays::RemoveFirst() {  int firstIndex = Remove(0);  return firstIndex;}// Removes the last element in the array and returns it// Preconditions: 0 is less than the size of the array// Postconditions: The size of the array will be array - 1int DynamicArrays::RemoveLast() {  int lastIndex = Remove(size - 1);  return lastIndex;}